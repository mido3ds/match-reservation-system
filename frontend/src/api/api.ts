/* tslint:disable */
/* eslint-disable */
/**
 * Match Reservation API
 * API for Match Reservation Website
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CreditCard
 */
export interface CreditCard {
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    creditCardNumber: string;
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    pin: string;
}
/**
 * User sends this object when they edit their profile
 * @export
 * @interface EditedUser
 */
export interface EditedUser {
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    birthDate?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    gender?: EditedUserGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    role?: EditedUserRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EditedUserGenderEnum {
    Male = 'male',
    Female = 'female'
}
/**
    * @export
    * @enum {string}
    */
export enum EditedUserRoleEnum {
    Fan = 'fan',
    Manager = 'manager'
}

/**
 * when an error happens, this holds the error description
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    err: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    password: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    has_next: boolean;
    /**
     * 
     * @type {Array<ListedUser>}
     * @memberof InlineResponse200
     */
    users: Array<ListedUser>;
}
/**
 * successful signup
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    authToken: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    msg: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2002
     */
    logout: boolean;
    /**
     * 
     * @type {Array<ListedUser>}
     * @memberof InlineResponse2002
     */
    user: Array<ListedUser>;
    /**
     * in case the user asked to be a manger, send a message to display to assure they will be reviewed
     * @type {string}
     * @memberof InlineResponse2002
     */
    msg?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    authToken: string;
    /**
     * used by the forntend to know the type of the user, the backend still needs to check the payload of the authToken payload
     * @type {string}
     * @memberof InlineResponse2003
     */
    userType: InlineResponse2003UserTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2003UserTypeEnum {
    Fan = 'fan',
    Manager = 'manager',
    Admin = 'admin'
}

/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2004
     */
    has_next: boolean;
    /**
     * 
     * @type {Array<ListedUser>}
     * @memberof InlineResponse2004
     */
    requestedManagers: Array<ListedUser>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005
     */
    has_next: boolean;
    /**
     * 
     * @type {Array<ListedMatch>}
     * @memberof InlineResponse2005
     */
    matches: Array<ListedMatch>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006
     */
    has_next: boolean;
    /**
     * 
     * @type {Array<MatchTicket>}
     * @memberof InlineResponse2006
     */
    tickets: Array<MatchTicket>;
    /**
     * 
     * @type {Array<ListedMatch>}
     * @memberof InlineResponse2006
     */
    matches: Array<ListedMatch>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2007
     */
    has_next: boolean;
    /**
     * 
     * @type {Array<ListedStadium>}
     * @memberof InlineResponse2007
     */
    stadiums: Array<ListedStadium>;
}
/**
 * 
 * @export
 * @interface ListedMatch
 */
export interface ListedMatch {
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    homeTeam: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    awayTeam: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    venue: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    dateTime: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    mainReferee: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    firstLinesman: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    secondLinesman: string;
    /**
     * 
     * @type {number}
     * @memberof ListedMatch
     */
    ticketPrice: number;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    uuid: string;
}
/**
 * 
 * @export
 * @interface ListedStadium
 */
export interface ListedStadium {
    /**
     * 
     * @type {string}
     * @memberof ListedStadium
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ListedStadium
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof ListedStadium
     */
    uuid: string;
    /**
     * 
     * @type {number}
     * @memberof ListedStadium
     */
    rows: number;
    /**
     * 
     * @type {number}
     * @memberof ListedStadium
     */
    seatsPerRow: number;
}
/**
 * This is the object sent to frontend when it asks to list user
 * @export
 * @interface ListedUser
 */
export interface ListedUser {
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    birthDate: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    gender: ListedUserGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    email: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListedUserGenderEnum {
    Male = 'male',
    Female = 'female'
}

/**
 * 
 * @export
 * @interface MatchTicket
 */
export interface MatchTicket {
    /**
     * 
     * @type {string}
     * @memberof MatchTicket
     */
    uuid: string;
    /**
     * 
     * @type {string}
     * @memberof MatchTicket
     */
    matchUUID?: string;
    /**
     * 
     * @type {string}
     * @memberof MatchTicket
     */
    seatID: string;
    /**
     * 
     * @type {number}
     * @memberof MatchTicket
     */
    price?: number;
}
/**
 * 
 * @export
 * @interface SubmittedMatch
 */
export interface SubmittedMatch {
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    homeTeam: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    awayTeam: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    venue: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    dateTime: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    mainReferee: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    firstLinesman: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    secondLinesman: string;
}
/**
 * 
 * @export
 * @interface SubmittedStadium
 */
export interface SubmittedStadium {
    /**
     * 
     * @type {string}
     * @memberof SubmittedStadium
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedStadium
     */
    city: string;
    /**
     * 
     * @type {number}
     * @memberof SubmittedStadium
     */
    rows: number;
    /**
     * 
     * @type {number}
     * @memberof SubmittedStadium
     */
    seatsPerRow: number;
}
/**
 * User sends this object when they first signup
 * @export
 * @interface SubmittedUser
 */
export interface SubmittedUser {
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    birthDate: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    gender: SubmittedUserGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    role: SubmittedUserRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SubmittedUserGenderEnum {
    Male = 'male',
    Female = 'female'
}
/**
    * @export
    * @enum {string}
    */
export enum SubmittedUserRoleEnum {
    Fan = 'fan',
    Manager = 'manager'
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary accept a request
         * @param {string} xAuthToken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptManagersRequest: async (xAuthToken: string, username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling acceptManagersRequest.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling acceptManagersRequest.');
            }
            const localVarPath = `/api/managers/requests/accept/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel ticket
         * @param {string} ticketId 
         * @param {string} xAuthToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTicket: async (ticketId: string, xAuthToken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            if (ticketId === null || ticketId === undefined) {
                throw new RequiredError('ticketId','Required parameter ticketId was null or undefined when calling cancelTicket.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling cancelTicket.');
            }
            const localVarPath = `/api/tickets/{ticket_id}`
                .replace(`{${"ticket_id"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a match
         * @param {string} xAuthToken 
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMatch: async (xAuthToken: string, matchId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling deleteMatch.');
            }
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling deleteMatch.');
            }
            const localVarPath = `/api/matches/{match_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a stadium
         * @param {string} xAuthToken 
         * @param {string} stadiumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStadium: async (xAuthToken: string, stadiumId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling deleteStadium.');
            }
            // verify required parameter 'stadiumId' is not null or undefined
            if (stadiumId === null || stadiumId === undefined) {
                throw new RequiredError('stadiumId','Required parameter stadiumId was null or undefined when calling deleteStadium.');
            }
            const localVarPath = `/api/stadiums/{stadium_id}`
                .replace(`{${"stadium_id"}}`, encodeURIComponent(String(stadiumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a user
         * @param {string} username 
         * @param {string} xAuthToken must be an admin, or the account owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (username: string, xAuthToken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteUser.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/api/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary edit a match
         * @param {string} xAuthToken 
         * @param {string} matchId 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMatch: async (xAuthToken: string, matchId: string, submittedMatch?: SubmittedMatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling editMatch.');
            }
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling editMatch.');
            }
            const localVarPath = `/api/matches/{match_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof submittedMatch !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(submittedMatch !== undefined ? submittedMatch : {})
                : (submittedMatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary edit user
         * @param {string} xAuthToken 
         * @param {EditedUser} [editedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (xAuthToken: string, editedUser?: EditedUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling editUser.');
            }
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof editedUser !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(editedUser !== undefined ? editedUser : {})
                : (editedUser || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list requests for management
         * @param {string} xAuthToken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagersRequests: async (xAuthToken: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling getManagersRequests.');
            }
            const localVarPath = `/api/managers/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get one match
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatch: async (matchId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling getMatch.');
            }
            const localVarPath = `/api/matches/{match_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all user tickets in a match
         * @param {string} xAuthToken 
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchTickets: async (xAuthToken: string, matchId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling getMatchTickets.');
            }
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling getMatchTickets.');
            }
            const localVarPath = `/api/tickets/{match_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get matches
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get my info
         * @param {string} xAuthToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyInfo: async (xAuthToken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling getMyInfo.');
            }
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get seats of given match
         * @param {string} matchId 
         * @param {string} [xAuthToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeats: async (matchId: string, xAuthToken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling getSeats.');
            }
            const localVarPath = `/api/matches/{match_id}/seats`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all stadiums
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStadiums: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stadiums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all stadiums names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStadiumsNames: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stadiums/names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all user tickets
         * @param {string} xAuthToken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickets: async (xAuthToken: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling getTickets.');
            }
            const localVarPath = `/api/tickets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all users
         * @param {string} xAuthToken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (xAuthToken: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling getUsers.');
            }
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get auth token
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof inlineObject !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(inlineObject !== undefined ? inlineObject : {})
                : (inlineObject || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary reject a request
         * @param {string} xAuthToken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectManagersRequest: async (xAuthToken: string, username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling rejectManagersRequest.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling rejectManagersRequest.');
            }
            const localVarPath = `/api/managers/requests/reject/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary reserve seat
         * @param {string} matchId 
         * @param {string} seatId 
         * @param {string} xAuthToken 
         * @param {CreditCard} [creditCard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reserveSeat: async (matchId: string, seatId: string, xAuthToken: string, creditCard?: CreditCard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling reserveSeat.');
            }
            // verify required parameter 'seatId' is not null or undefined
            if (seatId === null || seatId === undefined) {
                throw new RequiredError('seatId','Required parameter seatId was null or undefined when calling reserveSeat.');
            }
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling reserveSeat.');
            }
            const localVarPath = `/api/matches/{match_id}/seats/reserve/{seat_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)))
                .replace(`{${"seat_id"}}`, encodeURIComponent(String(seatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof creditCard !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(creditCard !== undefined ? creditCard : {})
                : (creditCard || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signup
         * @param {SubmittedUser} [submittedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (submittedUser?: SubmittedUser, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof submittedUser !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(submittedUser !== undefined ? submittedUser : {})
                : (submittedUser || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary submit a match
         * @param {string} xAuthToken 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMatch: async (xAuthToken: string, submittedMatch?: SubmittedMatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling submitMatch.');
            }
            const localVarPath = `/api/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof submittedMatch !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(submittedMatch !== undefined ? submittedMatch : {})
                : (submittedMatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary submit a stadium
         * @param {string} xAuthToken 
         * @param {SubmittedStadium} [submittedStadium] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitStadium: async (xAuthToken: string, submittedStadium?: SubmittedStadium, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'xAuthToken' is not null or undefined
            if (xAuthToken === null || xAuthToken === undefined) {
                throw new RequiredError('xAuthToken','Required parameter xAuthToken was null or undefined when calling submitStadium.');
            }
            const localVarPath = `/api/stadiums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xAuthToken !== undefined && xAuthToken !== null) {
                localVarHeaderParameter['x-auth-token'] = String(xAuthToken);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof submittedStadium !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(submittedStadium !== undefined ? submittedStadium : {})
                : (submittedStadium || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary accept a request
         * @param {string} xAuthToken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptManagersRequest(xAuthToken: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).acceptManagersRequest(xAuthToken, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary cancel ticket
         * @param {string} ticketId 
         * @param {string} xAuthToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTicket(ticketId: string, xAuthToken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).cancelTicket(ticketId, xAuthToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary delete a match
         * @param {string} xAuthToken 
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMatch(xAuthToken: string, matchId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteMatch(xAuthToken, matchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary delete a stadium
         * @param {string} xAuthToken 
         * @param {string} stadiumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStadium(xAuthToken: string, stadiumId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteStadium(xAuthToken, stadiumId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary delete a user
         * @param {string} username 
         * @param {string} xAuthToken must be an admin, or the account owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(username: string, xAuthToken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteUser(username, xAuthToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary edit a match
         * @param {string} xAuthToken 
         * @param {string} matchId 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editMatch(xAuthToken: string, matchId: string, submittedMatch?: SubmittedMatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).editMatch(xAuthToken, matchId, submittedMatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary edit user
         * @param {string} xAuthToken 
         * @param {EditedUser} [editedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(xAuthToken: string, editedUser?: EditedUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).editUser(xAuthToken, editedUser, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary list requests for management
         * @param {string} xAuthToken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManagersRequests(xAuthToken: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getManagersRequests(xAuthToken, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get one match
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatch(matchId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedMatch>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getMatch(matchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all user tickets in a match
         * @param {string} xAuthToken 
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatchTickets(xAuthToken: string, matchId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MatchTicket>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getMatchTickets(xAuthToken, matchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get matches
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatches(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getMatches(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get my info
         * @param {string} xAuthToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyInfo(xAuthToken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedUser>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getMyInfo(xAuthToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get seats of given match
         * @param {string} matchId 
         * @param {string} [xAuthToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeats(matchId: string, xAuthToken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getSeats(matchId, xAuthToken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all stadiums
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStadiums(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getStadiums(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all stadiums names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStadiumsNames(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getStadiumsNames(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all user tickets
         * @param {string} xAuthToken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickets(xAuthToken: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getTickets(xAuthToken, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all users
         * @param {string} xAuthToken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(xAuthToken: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getUsers(xAuthToken, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get auth token
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).login(inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary reject a request
         * @param {string} xAuthToken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectManagersRequest(xAuthToken: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).rejectManagersRequest(xAuthToken, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary reserve seat
         * @param {string} matchId 
         * @param {string} seatId 
         * @param {string} xAuthToken 
         * @param {CreditCard} [creditCard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reserveSeat(matchId: string, seatId: string, xAuthToken: string, creditCard?: CreditCard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).reserveSeat(matchId, seatId, xAuthToken, creditCard, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary signup
         * @param {SubmittedUser} [submittedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(submittedUser?: SubmittedUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).signup(submittedUser, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary submit a match
         * @param {string} xAuthToken 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitMatch(xAuthToken: string, submittedMatch?: SubmittedMatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).submitMatch(xAuthToken, submittedMatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary submit a stadium
         * @param {string} xAuthToken 
         * @param {SubmittedStadium} [submittedStadium] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitStadium(xAuthToken: string, submittedStadium?: SubmittedStadium, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).submitStadium(xAuthToken, submittedStadium, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary accept a request
         * @param {string} xAuthToken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptManagersRequest(xAuthToken: string, username: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).acceptManagersRequest(xAuthToken, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel ticket
         * @param {string} ticketId 
         * @param {string} xAuthToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTicket(ticketId: string, xAuthToken: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).cancelTicket(ticketId, xAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete a match
         * @param {string} xAuthToken 
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMatch(xAuthToken: string, matchId: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteMatch(xAuthToken, matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete a stadium
         * @param {string} xAuthToken 
         * @param {string} stadiumId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStadium(xAuthToken: string, stadiumId: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteStadium(xAuthToken, stadiumId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete a user
         * @param {string} username 
         * @param {string} xAuthToken must be an admin, or the account owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, xAuthToken: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteUser(username, xAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary edit a match
         * @param {string} xAuthToken 
         * @param {string} matchId 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMatch(xAuthToken: string, matchId: string, submittedMatch?: SubmittedMatch, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).editMatch(xAuthToken, matchId, submittedMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary edit user
         * @param {string} xAuthToken 
         * @param {EditedUser} [editedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(xAuthToken: string, editedUser?: EditedUser, options?: any): AxiosPromise<InlineResponse2002> {
            return DefaultApiFp(configuration).editUser(xAuthToken, editedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list requests for management
         * @param {string} xAuthToken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagersRequests(xAuthToken: string, page?: number, options?: any): AxiosPromise<InlineResponse2004> {
            return DefaultApiFp(configuration).getManagersRequests(xAuthToken, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get one match
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatch(matchId: string, options?: any): AxiosPromise<ListedMatch> {
            return DefaultApiFp(configuration).getMatch(matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all user tickets in a match
         * @param {string} xAuthToken 
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatchTickets(xAuthToken: string, matchId: string, options?: any): AxiosPromise<Array<MatchTicket>> {
            return DefaultApiFp(configuration).getMatchTickets(xAuthToken, matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get matches
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches(page?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return DefaultApiFp(configuration).getMatches(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get my info
         * @param {string} xAuthToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyInfo(xAuthToken: string, options?: any): AxiosPromise<ListedUser> {
            return DefaultApiFp(configuration).getMyInfo(xAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get seats of given match
         * @param {string} matchId 
         * @param {string} [xAuthToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeats(matchId: string, xAuthToken?: string, options?: any): AxiosPromise<object> {
            return DefaultApiFp(configuration).getSeats(matchId, xAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all stadiums
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStadiums(page?: number, options?: any): AxiosPromise<InlineResponse2007> {
            return DefaultApiFp(configuration).getStadiums(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all stadiums names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStadiumsNames(options?: any): AxiosPromise<Array<string>> {
            return DefaultApiFp(configuration).getStadiumsNames(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all user tickets
         * @param {string} xAuthToken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickets(xAuthToken: string, page?: number, options?: any): AxiosPromise<InlineResponse2006> {
            return DefaultApiFp(configuration).getTickets(xAuthToken, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all users
         * @param {string} xAuthToken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(xAuthToken: string, page?: number, options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).getUsers(xAuthToken, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get auth token
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(inlineObject?: InlineObject, options?: any): AxiosPromise<InlineResponse2003> {
            return DefaultApiFp(configuration).login(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary reject a request
         * @param {string} xAuthToken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectManagersRequest(xAuthToken: string, username: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).rejectManagersRequest(xAuthToken, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary reserve seat
         * @param {string} matchId 
         * @param {string} seatId 
         * @param {string} xAuthToken 
         * @param {CreditCard} [creditCard] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reserveSeat(matchId: string, seatId: string, xAuthToken: string, creditCard?: CreditCard, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).reserveSeat(matchId, seatId, xAuthToken, creditCard, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary signup
         * @param {SubmittedUser} [submittedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(submittedUser?: SubmittedUser, options?: any): AxiosPromise<InlineResponse2001> {
            return DefaultApiFp(configuration).signup(submittedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary submit a match
         * @param {string} xAuthToken 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMatch(xAuthToken: string, submittedMatch?: SubmittedMatch, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).submitMatch(xAuthToken, submittedMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary submit a stadium
         * @param {string} xAuthToken 
         * @param {SubmittedStadium} [submittedStadium] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitStadium(xAuthToken: string, submittedStadium?: SubmittedStadium, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).submitStadium(xAuthToken, submittedStadium, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary accept a request
     * @param {string} xAuthToken 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public acceptManagersRequest(xAuthToken: string, username: string, options?: any) {
        return DefaultApiFp(this.configuration).acceptManagersRequest(xAuthToken, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary cancel ticket
     * @param {string} ticketId 
     * @param {string} xAuthToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelTicket(ticketId: string, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).cancelTicket(ticketId, xAuthToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete a match
     * @param {string} xAuthToken 
     * @param {string} matchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteMatch(xAuthToken: string, matchId: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteMatch(xAuthToken, matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete a stadium
     * @param {string} xAuthToken 
     * @param {string} stadiumId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteStadium(xAuthToken: string, stadiumId: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteStadium(xAuthToken, stadiumId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete a user
     * @param {string} username 
     * @param {string} xAuthToken must be an admin, or the account owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteUser(username: string, xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteUser(username, xAuthToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary edit a match
     * @param {string} xAuthToken 
     * @param {string} matchId 
     * @param {SubmittedMatch} [submittedMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editMatch(xAuthToken: string, matchId: string, submittedMatch?: SubmittedMatch, options?: any) {
        return DefaultApiFp(this.configuration).editMatch(xAuthToken, matchId, submittedMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary edit user
     * @param {string} xAuthToken 
     * @param {EditedUser} [editedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editUser(xAuthToken: string, editedUser?: EditedUser, options?: any) {
        return DefaultApiFp(this.configuration).editUser(xAuthToken, editedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list requests for management
     * @param {string} xAuthToken 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getManagersRequests(xAuthToken: string, page?: number, options?: any) {
        return DefaultApiFp(this.configuration).getManagersRequests(xAuthToken, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get one match
     * @param {string} matchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMatch(matchId: string, options?: any) {
        return DefaultApiFp(this.configuration).getMatch(matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all user tickets in a match
     * @param {string} xAuthToken 
     * @param {string} matchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMatchTickets(xAuthToken: string, matchId: string, options?: any) {
        return DefaultApiFp(this.configuration).getMatchTickets(xAuthToken, matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get matches
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMatches(page?: number, options?: any) {
        return DefaultApiFp(this.configuration).getMatches(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get my info
     * @param {string} xAuthToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMyInfo(xAuthToken: string, options?: any) {
        return DefaultApiFp(this.configuration).getMyInfo(xAuthToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get seats of given match
     * @param {string} matchId 
     * @param {string} [xAuthToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSeats(matchId: string, xAuthToken?: string, options?: any) {
        return DefaultApiFp(this.configuration).getSeats(matchId, xAuthToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all stadiums
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStadiums(page?: number, options?: any) {
        return DefaultApiFp(this.configuration).getStadiums(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all stadiums names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStadiumsNames(options?: any) {
        return DefaultApiFp(this.configuration).getStadiumsNames(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all user tickets
     * @param {string} xAuthToken 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTickets(xAuthToken: string, page?: number, options?: any) {
        return DefaultApiFp(this.configuration).getTickets(xAuthToken, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all users
     * @param {string} xAuthToken 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUsers(xAuthToken: string, page?: number, options?: any) {
        return DefaultApiFp(this.configuration).getUsers(xAuthToken, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get auth token
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(inlineObject?: InlineObject, options?: any) {
        return DefaultApiFp(this.configuration).login(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary reject a request
     * @param {string} xAuthToken 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rejectManagersRequest(xAuthToken: string, username: string, options?: any) {
        return DefaultApiFp(this.configuration).rejectManagersRequest(xAuthToken, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary reserve seat
     * @param {string} matchId 
     * @param {string} seatId 
     * @param {string} xAuthToken 
     * @param {CreditCard} [creditCard] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reserveSeat(matchId: string, seatId: string, xAuthToken: string, creditCard?: CreditCard, options?: any) {
        return DefaultApiFp(this.configuration).reserveSeat(matchId, seatId, xAuthToken, creditCard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary signup
     * @param {SubmittedUser} [submittedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signup(submittedUser?: SubmittedUser, options?: any) {
        return DefaultApiFp(this.configuration).signup(submittedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary submit a match
     * @param {string} xAuthToken 
     * @param {SubmittedMatch} [submittedMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitMatch(xAuthToken: string, submittedMatch?: SubmittedMatch, options?: any) {
        return DefaultApiFp(this.configuration).submitMatch(xAuthToken, submittedMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary submit a stadium
     * @param {string} xAuthToken 
     * @param {SubmittedStadium} [submittedStadium] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitStadium(xAuthToken: string, submittedStadium?: SubmittedStadium, options?: any) {
        return DefaultApiFp(this.configuration).submitStadium(xAuthToken, submittedStadium, options).then((request) => request(this.axios, this.basePath));
    }
}


