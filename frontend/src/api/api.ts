/* tslint:disable */
/* eslint-disable */
/**
 * Match Reservation API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CreditCard
 */
export interface CreditCard {
    /**
     * 
     * @type {string}
     * @memberof CreditCard
     */
    creditCardNumber: string;
    /**
     * 
     * @type {number}
     * @memberof CreditCard
     */
    pin: number;
}
/**
 * User sends this object when they edit their profile
 * @export
 * @interface EditedUser
 */
export interface EditedUser {
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    birthDate?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    gender?: EditedUserGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof EditedUser
     */
    role?: EditedUserRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EditedUserGenderEnum {
    Male = 'male',
    Female = 'female'
}
/**
    * @export
    * @enum {string}
    */
export enum EditedUserRoleEnum {
    Fan = 'fan',
    Manager = 'manager'
}

/**
 * when an error happens, this holds the error description
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    err: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    password: string;
}
/**
 * successful signup
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    authToken: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    msg?: string;
}
/**
 * successful edit
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * in case the user asked to be a manger, send a message to display to assure they will be reviewed
     * @type {string}
     * @memberof InlineResponse2001
     */
    msg?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    authToken: string;
    /**
     * used by the forntend to know the type of the user, the backend still needs to check the payload of the authToken payload
     * @type {string}
     * @memberof InlineResponse2002
     */
    userType?: InlineResponse2002UserTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineResponse2002UserTypeEnum {
    Fan = 'fan',
    Manager = 'manager',
    Admin = 'admin'
}

/**
 * 
 * @export
 * @interface ListedMatch
 */
export interface ListedMatch {
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    homeTeam: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    awayTeam: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    venue: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    dateTime: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    mainReferee: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    firstLinesman: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    secondLinesman: string;
    /**
     * 
     * @type {string}
     * @memberof ListedMatch
     */
    uuid: string;
}
/**
 * 
 * @export
 * @interface ListedStadium
 */
export interface ListedStadium {
    /**
     * 
     * @type {string}
     * @memberof ListedStadium
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ListedStadium
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof ListedStadium
     */
    uuid: string;
}
/**
 * This is the object sent to frontend when it asks to list user
 * @export
 * @interface ListedUser
 */
export interface ListedUser {
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    birthDate: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    gender: ListedUserGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof ListedUser
     */
    email: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ListedUserGenderEnum {
    Male = 'male',
    Female = 'female'
}

/**
 * 
 * @export
 * @interface Seats
 */
export interface Seats {
    /**
     * reserved seats in this stadium
     * @type {Array<string>}
     * @memberof Seats
     */
    reserved: Array<string>;
    /**
     * tickets and seats reserved by user, if they provided their auth token
     * @type {{ [key: string]: object; }}
     * @memberof Seats
     */
    reservedByUser?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface SubmittedMatch
 */
export interface SubmittedMatch {
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    homeTeam: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    awayTeam: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    venue: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    dateTime: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    mainReferee: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    firstLinesman: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedMatch
     */
    secondLinesman: string;
}
/**
 * 
 * @export
 * @interface SubmittedStadium
 */
export interface SubmittedStadium {
    /**
     * 
     * @type {string}
     * @memberof SubmittedStadium
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedStadium
     */
    city: string;
}
/**
 * User sends this object when they first signup
 * @export
 * @interface SubmittedUser
 */
export interface SubmittedUser {
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    birthDate: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    gender: SubmittedUserGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SubmittedUser
     */
    role: SubmittedUserRoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SubmittedUserGenderEnum {
    Male = 'male',
    Female = 'female'
}
/**
    * @export
    * @enum {string}
    */
export enum SubmittedUserRoleEnum {
    Fan = 'fan',
    Manager = 'manager'
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary accept a request
         * @param {string} authtoken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptManagersRequest: async (authtoken: string, username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling acceptManagersRequest.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling acceptManagersRequest.');
            }
            const localVarPath = `/api/managers/requests/accept/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel seat
         * @param {string} matchId 
         * @param {string} seatId 
         * @param {string} authtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeat: async (matchId: string, seatId: string, authtoken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling cancelSeat.');
            }
            // verify required parameter 'seatId' is not null or undefined
            if (seatId === null || seatId === undefined) {
                throw new RequiredError('seatId','Required parameter seatId was null or undefined when calling cancelSeat.');
            }
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling cancelSeat.');
            }
            const localVarPath = `/api/matches/{match_id}/seats/reserve/{seat_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)))
                .replace(`{${"seat_id"}}`, encodeURIComponent(String(seatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary cancel ticket
         * @param {string} ticketId 
         * @param {string} authtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTicket: async (ticketId: string, authtoken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticketId' is not null or undefined
            if (ticketId === null || ticketId === undefined) {
                throw new RequiredError('ticketId','Required parameter ticketId was null or undefined when calling cancelTicket.');
            }
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling cancelTicket.');
            }
            const localVarPath = `/api/tickets/{ticket_id}`
                .replace(`{${"ticket_id"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete a user
         * @param {string} username 
         * @param {string} authtoken must be an admin, or the account owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (username: string, authtoken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling deleteUser.');
            }
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/api/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary edit a match
         * @param {string} authtoken 
         * @param {string} matchId 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMatch: async (authtoken: string, matchId: string, submittedMatch?: SubmittedMatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling editMatch.');
            }
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling editMatch.');
            }
            const localVarPath = `/api/matches/{match_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof submittedMatch !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(submittedMatch !== undefined ? submittedMatch : {})
                : (submittedMatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary edit user
         * @param {string} username 
         * @param {string} authtoken 
         * @param {EditedUser} [editedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (username: string, authtoken: string, editedUser?: EditedUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling editUser.');
            }
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling editUser.');
            }
            const localVarPath = `/api/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof editedUser !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(editedUser !== undefined ? editedUser : {})
                : (editedUser || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary list requests for management
         * @param {string} authtoken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagersRequests: async (authtoken: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling getManagersRequests.');
            }
            const localVarPath = `/api/managers/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get one match
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatch: async (matchId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling getMatch.');
            }
            const localVarPath = `/api/matches/{match_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get matches
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get seats of given match
         * @param {string} matchId 
         * @param {string} [authtoken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeats: async (matchId: string, authtoken?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling getSeats.');
            }
            const localVarPath = `/api/matches/{match_id}/seats`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all stadiums
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStadiums: async (page?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stadiums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get all users
         * @param {string} authtoken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (authtoken: string, page?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling getUsers.');
            }
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get auth token
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof inlineObject !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(inlineObject !== undefined ? inlineObject : {})
                : (inlineObject || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary reject a request
         * @param {string} authtoken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectManagersRequest: async (authtoken: string, username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling rejectManagersRequest.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling rejectManagersRequest.');
            }
            const localVarPath = `/api/managers/requests/reject/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary reserve seat
         * @param {string} matchId 
         * @param {string} seatId 
         * @param {string} authtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reserveSeat: async (matchId: string, seatId: string, authtoken: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            if (matchId === null || matchId === undefined) {
                throw new RequiredError('matchId','Required parameter matchId was null or undefined when calling reserveSeat.');
            }
            // verify required parameter 'seatId' is not null or undefined
            if (seatId === null || seatId === undefined) {
                throw new RequiredError('seatId','Required parameter seatId was null or undefined when calling reserveSeat.');
            }
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling reserveSeat.');
            }
            const localVarPath = `/api/matches/{match_id}/seats/reserve/{seat_id}`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)))
                .replace(`{${"seat_id"}}`, encodeURIComponent(String(seatId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signup
         * @param {SubmittedUser} [submittedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (submittedUser?: SubmittedUser, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof submittedUser !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(submittedUser !== undefined ? submittedUser : {})
                : (submittedUser || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary submit a match
         * @param {string} authtoken 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMatch: async (authtoken: string, submittedMatch?: SubmittedMatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling submitMatch.');
            }
            const localVarPath = `/api/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof submittedMatch !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(submittedMatch !== undefined ? submittedMatch : {})
                : (submittedMatch || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary submit a stadium
         * @param {string} authtoken 
         * @param {SubmittedStadium} [submittedStadium] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitStadium: async (authtoken: string, submittedStadium?: SubmittedStadium, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authtoken' is not null or undefined
            if (authtoken === null || authtoken === undefined) {
                throw new RequiredError('authtoken','Required parameter authtoken was null or undefined when calling submitStadium.');
            }
            const localVarPath = `/api/stadiums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof submittedStadium !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(submittedStadium !== undefined ? submittedStadium : {})
                : (submittedStadium || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary accept a request
         * @param {string} authtoken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptManagersRequest(authtoken: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).acceptManagersRequest(authtoken, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary cancel seat
         * @param {string} matchId 
         * @param {string} seatId 
         * @param {string} authtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSeat(matchId: string, seatId: string, authtoken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).cancelSeat(matchId, seatId, authtoken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary cancel ticket
         * @param {string} ticketId 
         * @param {string} authtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTicket(ticketId: string, authtoken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).cancelTicket(ticketId, authtoken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary delete a user
         * @param {string} username 
         * @param {string} authtoken must be an admin, or the account owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(username: string, authtoken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).deleteUser(username, authtoken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary edit a match
         * @param {string} authtoken 
         * @param {string} matchId 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editMatch(authtoken: string, matchId: string, submittedMatch?: SubmittedMatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).editMatch(authtoken, matchId, submittedMatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary edit user
         * @param {string} username 
         * @param {string} authtoken 
         * @param {EditedUser} [editedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(username: string, authtoken: string, editedUser?: EditedUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).editUser(username, authtoken, editedUser, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary list requests for management
         * @param {string} authtoken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManagersRequests(authtoken: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListedUser>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getManagersRequests(authtoken, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get one match
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatch(matchId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListedMatch>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getMatch(matchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get matches
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatches(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListedMatch>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getMatches(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get seats of given match
         * @param {string} matchId 
         * @param {string} [authtoken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeats(matchId: string, authtoken?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Seats>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getSeats(matchId, authtoken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all stadiums
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStadiums(page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListedStadium>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getStadiums(page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get all users
         * @param {string} authtoken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(authtoken: string, page?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListedUser>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getUsers(authtoken, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary get auth token
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).login(inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary reject a request
         * @param {string} authtoken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectManagersRequest(authtoken: string, username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).rejectManagersRequest(authtoken, username, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary reserve seat
         * @param {string} matchId 
         * @param {string} seatId 
         * @param {string} authtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reserveSeat(matchId: string, seatId: string, authtoken: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreditCard>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).reserveSeat(matchId, seatId, authtoken, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary signup
         * @param {SubmittedUser} [submittedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(submittedUser?: SubmittedUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).signup(submittedUser, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary submit a match
         * @param {string} authtoken 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitMatch(authtoken: string, submittedMatch?: SubmittedMatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).submitMatch(authtoken, submittedMatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary submit a stadium
         * @param {string} authtoken 
         * @param {SubmittedStadium} [submittedStadium] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitStadium(authtoken: string, submittedStadium?: SubmittedStadium, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).submitStadium(authtoken, submittedStadium, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary accept a request
         * @param {string} authtoken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptManagersRequest(authtoken: string, username: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).acceptManagersRequest(authtoken, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel seat
         * @param {string} matchId 
         * @param {string} seatId 
         * @param {string} authtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeat(matchId: string, seatId: string, authtoken: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).cancelSeat(matchId, seatId, authtoken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary cancel ticket
         * @param {string} ticketId 
         * @param {string} authtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTicket(ticketId: string, authtoken: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).cancelTicket(ticketId, authtoken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete a user
         * @param {string} username 
         * @param {string} authtoken must be an admin, or the account owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, authtoken: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).deleteUser(username, authtoken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary edit a match
         * @param {string} authtoken 
         * @param {string} matchId 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMatch(authtoken: string, matchId: string, submittedMatch?: SubmittedMatch, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).editMatch(authtoken, matchId, submittedMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary edit user
         * @param {string} username 
         * @param {string} authtoken 
         * @param {EditedUser} [editedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(username: string, authtoken: string, editedUser?: EditedUser, options?: any): AxiosPromise<InlineResponse2001> {
            return DefaultApiFp(configuration).editUser(username, authtoken, editedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary list requests for management
         * @param {string} authtoken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagersRequests(authtoken: string, page?: number, options?: any): AxiosPromise<Array<ListedUser>> {
            return DefaultApiFp(configuration).getManagersRequests(authtoken, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get one match
         * @param {string} matchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatch(matchId: string, options?: any): AxiosPromise<ListedMatch> {
            return DefaultApiFp(configuration).getMatch(matchId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get matches
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches(page?: number, options?: any): AxiosPromise<Array<ListedMatch>> {
            return DefaultApiFp(configuration).getMatches(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get seats of given match
         * @param {string} matchId 
         * @param {string} [authtoken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeats(matchId: string, authtoken?: string, options?: any): AxiosPromise<Seats> {
            return DefaultApiFp(configuration).getSeats(matchId, authtoken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all stadiums
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStadiums(page?: number, options?: any): AxiosPromise<Array<ListedStadium>> {
            return DefaultApiFp(configuration).getStadiums(page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get all users
         * @param {string} authtoken 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(authtoken: string, page?: number, options?: any): AxiosPromise<Array<ListedUser>> {
            return DefaultApiFp(configuration).getUsers(authtoken, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get auth token
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(inlineObject?: InlineObject, options?: any): AxiosPromise<InlineResponse2002> {
            return DefaultApiFp(configuration).login(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary reject a request
         * @param {string} authtoken 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectManagersRequest(authtoken: string, username: string, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).rejectManagersRequest(authtoken, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary reserve seat
         * @param {string} matchId 
         * @param {string} seatId 
         * @param {string} authtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reserveSeat(matchId: string, seatId: string, authtoken: string, options?: any): AxiosPromise<CreditCard> {
            return DefaultApiFp(configuration).reserveSeat(matchId, seatId, authtoken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary signup
         * @param {SubmittedUser} [submittedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(submittedUser?: SubmittedUser, options?: any): AxiosPromise<InlineResponse200> {
            return DefaultApiFp(configuration).signup(submittedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary submit a match
         * @param {string} authtoken 
         * @param {SubmittedMatch} [submittedMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMatch(authtoken: string, submittedMatch?: SubmittedMatch, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).submitMatch(authtoken, submittedMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary submit a stadium
         * @param {string} authtoken 
         * @param {SubmittedStadium} [submittedStadium] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitStadium(authtoken: string, submittedStadium?: SubmittedStadium, options?: any): AxiosPromise<void> {
            return DefaultApiFp(configuration).submitStadium(authtoken, submittedStadium, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary accept a request
     * @param {string} authtoken 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public acceptManagersRequest(authtoken: string, username: string, options?: any) {
        return DefaultApiFp(this.configuration).acceptManagersRequest(authtoken, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary cancel seat
     * @param {string} matchId 
     * @param {string} seatId 
     * @param {string} authtoken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelSeat(matchId: string, seatId: string, authtoken: string, options?: any) {
        return DefaultApiFp(this.configuration).cancelSeat(matchId, seatId, authtoken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary cancel ticket
     * @param {string} ticketId 
     * @param {string} authtoken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelTicket(ticketId: string, authtoken: string, options?: any) {
        return DefaultApiFp(this.configuration).cancelTicket(ticketId, authtoken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete a user
     * @param {string} username 
     * @param {string} authtoken must be an admin, or the account owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteUser(username: string, authtoken: string, options?: any) {
        return DefaultApiFp(this.configuration).deleteUser(username, authtoken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary edit a match
     * @param {string} authtoken 
     * @param {string} matchId 
     * @param {SubmittedMatch} [submittedMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editMatch(authtoken: string, matchId: string, submittedMatch?: SubmittedMatch, options?: any) {
        return DefaultApiFp(this.configuration).editMatch(authtoken, matchId, submittedMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary edit user
     * @param {string} username 
     * @param {string} authtoken 
     * @param {EditedUser} [editedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public editUser(username: string, authtoken: string, editedUser?: EditedUser, options?: any) {
        return DefaultApiFp(this.configuration).editUser(username, authtoken, editedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary list requests for management
     * @param {string} authtoken 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getManagersRequests(authtoken: string, page?: number, options?: any) {
        return DefaultApiFp(this.configuration).getManagersRequests(authtoken, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get one match
     * @param {string} matchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMatch(matchId: string, options?: any) {
        return DefaultApiFp(this.configuration).getMatch(matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get matches
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMatches(page?: number, options?: any) {
        return DefaultApiFp(this.configuration).getMatches(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get seats of given match
     * @param {string} matchId 
     * @param {string} [authtoken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSeats(matchId: string, authtoken?: string, options?: any) {
        return DefaultApiFp(this.configuration).getSeats(matchId, authtoken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all stadiums
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStadiums(page?: number, options?: any) {
        return DefaultApiFp(this.configuration).getStadiums(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get all users
     * @param {string} authtoken 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUsers(authtoken: string, page?: number, options?: any) {
        return DefaultApiFp(this.configuration).getUsers(authtoken, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get auth token
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public login(inlineObject?: InlineObject, options?: any) {
        return DefaultApiFp(this.configuration).login(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary reject a request
     * @param {string} authtoken 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rejectManagersRequest(authtoken: string, username: string, options?: any) {
        return DefaultApiFp(this.configuration).rejectManagersRequest(authtoken, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary reserve seat
     * @param {string} matchId 
     * @param {string} seatId 
     * @param {string} authtoken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reserveSeat(matchId: string, seatId: string, authtoken: string, options?: any) {
        return DefaultApiFp(this.configuration).reserveSeat(matchId, seatId, authtoken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary signup
     * @param {SubmittedUser} [submittedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signup(submittedUser?: SubmittedUser, options?: any) {
        return DefaultApiFp(this.configuration).signup(submittedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary submit a match
     * @param {string} authtoken 
     * @param {SubmittedMatch} [submittedMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitMatch(authtoken: string, submittedMatch?: SubmittedMatch, options?: any) {
        return DefaultApiFp(this.configuration).submitMatch(authtoken, submittedMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary submit a stadium
     * @param {string} authtoken 
     * @param {SubmittedStadium} [submittedStadium] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitStadium(authtoken: string, submittedStadium?: SubmittedStadium, options?: any) {
        return DefaultApiFp(this.configuration).submitStadium(authtoken, submittedStadium, options).then((request) => request(this.axios, this.basePath));
    }
}


